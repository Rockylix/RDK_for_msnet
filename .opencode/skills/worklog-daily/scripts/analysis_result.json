{
  "capture": {
    "project": "RDK双摄像头实时显示",
    "category": "硬件",
    "date": "2026-02-01",
    "progress": [
      "VIO摄像头配置与图像采集(1920×1080)",
      "OpenCV集成与SSH X11转发实时显示",
      "VPS硬件编码尝试(失败,改用Sensor降分辨率)",
      "双摄像头640×480实时显示实现"
    ],
    "parameters": [
      "耗时: 64s",
      "分辨率: 320×240",
      "分辨率: 640×480"
    ],
    "issues": [
      "## 采用VPS进行测试\n1. 在使用vps进行处理之后，get_frame失败 （采用配置高宽为0，也失败）\n2. 使用统一句柄管理 也失败",
      "1. 在使用vps进行处理之后，get_frame失败 （采用配置高宽为0，也失败）\n2. 使用统一句柄管理 也失败\n\n**发现问题所在，vps是根据分辨率来区别的，但是我两张图片得到的分辨率一样，导致冲突，修改代码如下：**",
      "**发现问题所在，vps是根据分辨率来区别的，但是我两张图片得到的分辨率一样，导致冲突，修改代码如下：**\n```bash\nflowid module cid chn FREE  REQ  PRO  COM USED",
      "if ( ret_1 != 0 || ret_2 != 0) {\n        printf(\"Open camera failed\\n\");\n        return -1;\n    }",
      "else{\n            printf(\"Get frame failed! r1:%d r2:%d\\n\", r1, r2);\n        }\n         // 3. FPS 计算",
      "# 解决ssh转发但不影响帧率的做法\n采用sp官方api自带的摄像头硬件拍摄缩放功能，得到640x480的图像，等待缩放； 再开启第二路320x240的图像，显示，能够保持fps在30帧左右，解决问题。"
    ],
    "solutions": [
      "# vio 摄像头 SSH 实时显示实现\n将原文件从c 改为 cpp， 并且在Makefile中链接opencv库\n```shell\n# 获取 OpenCV 编译选项\nOPENCV_FLAGS := $(shell pkg-config --cflags --libs opencv4)",
      "# 采用vps 进行编码和缩放\n## opencv 方法如下:\n```cpp\nif (sp_vio_get_yuv(camera_1, yuv_ptr1, args.width, args.height, 2000) == 0 &&\n            sp_vio_get_yuv(camera_2, yuv_ptr2, args.width, args.height, 2000) == 0) {",
      "# 采用直接降分辨率方法\n![imx分辨率](./imx.png)\n修改代码如下：\n```cpp",
      "# 解决ssh转发但不影响帧率的做法\n采用sp官方api自带的摄像头硬件拍摄缩放功能，得到640x480的图像，等待缩放； 再开启第二路320x240的图像，显示，能够保持fps在30帧左右，解决问题。",
      "# 解决ssh转发但不影响帧率的做法\n采用sp官方api自带的摄像头硬件拍摄缩放功能，得到640x480的图像，等待缩放； 再开启第二路320x240的图像，显示，能够保持fps在30帧左右，解决问题。"
    ]
  },
  "msnet": {
    "project": "MSNet立体视觉深度估计",
    "category": "算法",
    "date_range": "2026-01-11 ~ 2026-01-26",
    "progress": [
      "Windows ↔ ARM NFS双向共享配置",
      "BPU模型加载流程实现(LoadModel→Inference→Postprocess)",
      "量化校准数据冲突问题定位与修复",
      "成功实现板载推理(640×352官方模型, 384×192自定义模型)"
    ],
    "parameters": [
      "耗时: 0.48ms",
      "耗时: 63.57ms",
      "分辨率: 384×192",
      "耗时: 6590.84ms",
      "大小: 90MB",
      "耗时: 262.11ms",
      "耗时: 97.04ms",
      "分辨率: 684×384",
      "大小: 33.75MB",
      "耗时: 21s",
      "分辨率: 640×352",
      "耗时: 21039.04ms",
      "耗时: 6.5s",
      "大小: 304MB",
      "分辨率: 192×384",
      "耗时: 36.93ms"
    ],
    "issues": [
      "## 问题待解决\n- 板载loadmodel 出现问题：错误码-6000002，加载模型失败。查看论坛没有发现原因。\n目前怀疑模型过大，下一步用小模型进行测试。",
      "## 问题待解决\n- 板载loadmodel 出现问题：错误码-6000002，加载模型失败。查看论坛没有发现原因。\n目前怀疑模型过大，下一步用小模型进行测试。\n![本地文件路径](./log/err_of_loading.png)",
      "# 1.13 load 问题解决\n## 问题描述\n在ARM开发板上使用BPU_loadModel加载模型时，出现错误码-6000002，导致模型加载失败。",
      "# 1.13 load 问题解决\n## 问题描述\n在ARM开发板上使用BPU_loadModel加载模型时，出现错误码-6000002，导致模型加载失败。\n## 原因分析",
      "## 问题描述\n在ARM开发板上使用BPU_loadModel加载模型时，出现错误码-6000002，导致模型加载失败。\n## 原因分析\n错误模型文件为**33.75MB**,而能够加载的模型文件为**90MB**，这是奇怪的一点。<br />",
      "## 原因分析\n错误模型文件为**33.75MB**,而能够加载的模型文件为**90MB**，这是奇怪的一点。<br />\n\n针对这一点我去检查docker环境内输出的模型大小，发现错误模型文件的原始文件应该为**304MB**，而不是加载的这个文件，说明在ssh拷贝过程中出现了问题。<br />",
      "针对这一点我去检查docker环境内输出的模型大小，发现错误模型文件的原始文件应该为**304MB**，而不是加载的这个文件，说明在ssh拷贝过程中出现了问题。<br />\n\n然后我发现，在向板载nfs 传输这个模型文件的时候，它需要时间，如果中断传输，则这个模型文件就会停滞，也就是一个错误的文件，也就无法加载，所以不是模型文件过大的问题。",
      "然后我发现，在向板载nfs 传输这个模型文件的时候，它需要时间，如果中断传输，则这个模型文件就会停滞，也就是一个错误的文件，也就无法加载，所以不是模型文件过大的问题。\n## 解决方案\n- 确定文件传输过程完整，文件完整，这样加载就成功.<br />",
      "- **640×352 $\\rightarrow$ 384×192**\n并重新生成了模型文件，成功解决了加载失败的问题.<br />\n记录加载时间 **6590.84ms = 6.5s**\n![\\本地图片](./log/success_of_192_384.png)",
      "## 内存空间占满导致功能失效\n在解决上述问题时，我有想过是不是内存不够导致的模型加载失败，于是我增加了swap空间，将内存完全占满了。导致几个问题\n\n-  内存占满，导致NTP服务崩溃：时间同步服务（ntpd、chronyd、systemd-timesyncd）需要内存运行。 **date**出现时间错误，导致makefile误检测，无法make",
      "-  内存占满，导致NTP服务崩溃：时间同步服务（ntpd、chronyd、systemd-timesyncd）需要内存运行。 **date**出现时间错误，导致makefile误检测，无法make\n- 内存占满导致，我没法进行编译，和相关的编辑提示",
      "2. 查看bpu是否工作。   bpu处于工作状态，并且确实在利用bpu推理时利用率最高\n3. 查看是否预处理完数据确实进入bpu。 更改了两张处理方式，一个是cut，一个是resize，**两个方式出来的图片一样，暂时怀疑是内存读写问题**。   不是内存读写问题，我打印了一些内存分配的偏置和校验和出来，确定缓存有读写\n4. 重新转换模型，排除nv12的干扰",
      "## 问题：\n你的校准数据准备脚本与你的 config 配置文件之间存在 三重致命冲突：\n1. 冲突 1：数值量程灾难（最严重）",
      "## 问题：\n你的校准数据准备脚本与你的 config 配置文件之间存在 三重致命冲突：\n1. 冲突 1：数值量程灾难（最严重）\n    脚本逻辑：log_np = np.array(log).astype(np.float32) / 255.0。你把像素缩放到了 [0, 1] 之间。",
      "你的校准数据准备脚本与你的 config 配置文件之间存在 三重致命冲突：\n1. 冲突 1：数值量程灾难（最严重）\n    脚本逻辑：log_np = np.array(log).astype(np.float32) / 255.0。你把像素缩放到了 [0, 1] 之间。\n    Config 配置：norm_type: 'data_mean_and_scale'，且 mean_value: 123.675...。",
      "网络接收到的信号几乎全被“淹没”在 -2 附近的死区里，根本提取不出任何纹理，所以无论你输入什么，输出都是一堆无意义的噪点。\n2. 冲突 2：内存排布（Layout）冲突\n    脚本逻辑：log_np = log_np.transpose(2, 0, 1)。你保存的是 CHW 排布。\n    Config 配置：input_layout_rt: 'NHWC'。",
      "这导致量化工具看到的图像是完全错位的“三色重叠怪”，计算出的量化参数（Scale/Offset）自然也是废的。\n3. 冲突 3：颜色通道（RGB vs BGR）\n    脚本逻辑：Image.open(...).convert('RGB')。\n    Config 配置：input_type_rt: 'bgr'。",
      "<mark>\n1. 在修改时发现一个很严重的问题，在处理校准数据时，一定要保证config中的校准数据和我随机选取的校准数据格式相同,例如图片格式为uint8，而不是float</br>\n2. 同时 在保存之后因为，bmp或者png文件头的原因，会导致字节数不对，这个时候可以添加,他会自动处理文件头字节来对齐校准数据\n3. 同时取消了校准数据时的 /255 ，这样会导致信号淹没，因为我本身config里面就开启了预处理，模型文件为msnet2d_bgr_192×384_new.bin"
    ],
    "solutions": [
      "Host board\n    HostName 192.168.127.10  # 改为你的开发板IP\n    User root\n    IdentityFile ~/.ssh/id_board\n    StrictHostKeyChecking no",
      "==**这样就可以实验板载直接访问我通过nfs服务共享的目录，进行基础文件的拷贝和一些权重文件的拷贝（如果我实时更新的话，比ssh更方便）**==\n\n## 问题待解决\n- 板载loadmodel 出现问题：错误码-6000002，加载模型失败。查看论坛没有发现原因。",
      "## 问题待解决\n- 板载loadmodel 出现问题：错误码-6000002，加载模型失败。查看论坛没有发现原因。\n目前怀疑模型过大，下一步用小模型进行测试。\n![本地文件路径](./log/err_of_loading.png)",
      "# 1.13 load 问题解决\n## 问题描述\n在ARM开发板上使用BPU_loadModel加载模型时，出现错误码-6000002，导致模型加载失败。\n## 原因分析",
      "然后我发现，在向板载nfs 传输这个模型文件的时候，它需要时间，如果中断传输，则这个模型文件就会停滞，也就是一个错误的文件，也就无法加载，所以不是模型文件过大的问题。\n## 解决方案\n- 确定文件传输过程完整，文件完整，这样加载就成功.<br />\n记录加载时间 **21039.04ms = 21s**\n![\\本地图片](./log/success_of_684_384.png)",
      "- **640×352 $\\rightarrow$ 384×192**\n并重新生成了模型文件，成功解决了加载失败的问题.<br />\n记录加载时间 **6590.84ms = 6.5s**\n![\\本地图片](./log/success_of_192_384.png)",
      "## 内存空间占满导致功能失效\n在解决上述问题时，我有想过是不是内存不够导致的模型加载失败，于是我增加了swap空间，将内存完全占满了。导致几个问题\n\n-  内存占满，导致NTP服务崩溃：时间同步服务（ntpd、chronyd、systemd-timesyncd）需要内存运行。 **date**出现时间错误，导致makefile误检测，无法make\n- 内存占满导致，我没法进行编译，和相关的编辑提示",
      "## 尝试解决办法\n1. 确定转换的初始onnx模型是否正常工作。   测试结果，转换的onnx模型能够正常推理\n2. 查看bpu是否工作。   bpu处于工作状态，并且确实在利用bpu推理时利用率最高\n3. 查看是否预处理完数据确实进入bpu。 更改了两张处理方式，一个是cut，一个是resize，**两个方式出来的图片一样，暂时怀疑是内存读写问题**。   不是内存读写问题，我打印了一些内存分配的偏置和校验和出来，确定缓存有读写",
      "# 1.26\n2. 并且我排除了letterbox的方法影响，只用cut的数据集来校准，效果还是无法明确看出\n\n3. 先排除模型文件的影响，采用 官方模型文件“DStereoV2.6_int8.bin”进行测试，官方(640×352)和msnet(384×192)、msnet(684×384)均采用resize处理，结果如下,成功实现板载推理：\n![result_official](./log/result_official.png)"
    ],
    "critical_findings": [
      "校准数据格式冲突(三重致命冲突):数值量程/内存排布/颜色通道",
      "NFS文件传输中断导致模型损坏(33.75MB异常,正常304MB)",
      "Swap内存占满导致NTP服务崩溃"
    ]
  }
}